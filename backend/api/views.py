# api/views.py

from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework.decorators import api_view, permission_classes
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.response import Response
from rest_framework import status
from django.utils.timezone import now
from django.contrib.auth import authenticate
from rest_framework import generics,filters
from rest_framework.permissions import IsAuthenticated,AllowAny
from .permissions import HasCapabilityPermission
from datetime import datetime,date
from decimal import Decimal
from django.shortcuts import get_object_or_404
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.exceptions import APIException
from django.db import IntegrityError
import json

# Generated by Django 5.2.1 on 2025-06-19 07:30
from api.models import StaffUser,Project,ProjectFinancePart,Partner,Translation,Department,PhaseType,Currency, ChatMessage,ProjectGipPart,ActionLog,WorkOrder,WorkOrderFile,JobPosition,UserTask,ChatMessageFile
from .serializers import (ProjectSerializer,
                          StaffUserSimpleSerializer,
                          ProjectFinancePartCreateSerializer,
                          WorkOrderCreateSerializer,
                          ProjectFinancePartSerializer,
                          PartnerSerializer,
                          TranslationSerializer,
                          DepartmentSerializer,
                          TranslationSerializer,
                          ProjectGipPartSerializer,
                          ActionLogSerializer,
                          WorkOrderSerializer,
                          CompleteWorkOrderSerializer,
                          ActionLogNotificationSerializer,
                          StaffManagementUserSerializer,
                          UserTaskSerializer,
                          SimpleJobPositionSerializer,
                          JobCreatePositionSerializer,
                          MyDepartmentTreeSerializer,
                          MyStaffTreeSerializer,
                          ChatMessageSerializer,
                          UnreadSimpleMessageSerializer,
                          CurrencySerializer)
from rest_framework.generics import ListCreateAPIView, RetrieveUpdateAPIView,ListAPIView,UpdateAPIView,CreateAPIView,DestroyAPIView,UpdateAPIView
from api.serializers import StaffUserTokenSerializer
from django.utils.dateparse import parse_date
from django.db.models import Count, Q,Subquery,OuterRef,F
from django.db import transaction
from .pagination import ProjectsPagination,ProjectsFiancierConfirmPagination,PartnersPagination,CompleteWorkOrderPagination,TranslationsPagination,GipConfirmPagination,ProjectListCreatePagination,ProjectGipPartPagination,NotificationsPagination,StaffManagementPagination,DepartmentPagination
from django.utils import timezone
from rest_framework.views import APIView
from rest_framework.exceptions import ValidationError
from rest_framework.filters import SearchFilter




class StaffUserLoginView(TokenObtainPairView):
    serializer_class = StaffUserTokenSerializer

    def post(self, request, *args, **kwargs):
        username = request.data.get("username")
        password = request.data.get("password")

        user = authenticate(request, username=username, password=password)

        if user is not None:
            # ‚úÖ Successful login ‚Äî update last_login
            user.last_login = now()
            user.save(update_fields=["last_login"])

            refresh = RefreshToken.for_user(user)

            # ‚úÖ Add custom claims
            refresh["user_id"] = user.user_id
            refresh["username"] = user.username
            refresh["fio"] = user.fio
            refresh["position"] = user.position.position_name if user.position else None
            refresh["role"] = user.role.role_name if user.role else None
            refresh["capabilities"] = list(
                user.role.capabilities.values_list("capability_name", flat=True)
            ) if user.role else []

            return Response({
                "refresh": str(refresh),
                "access": str(refresh.access_token),
            })

        # ‚ùå Failed login ‚Äî update last_login_time_fail
        try:
            failed_user = StaffUser.objects.get(username=username)
            failed_user.last_login_time_fail = now()
            failed_user.save(update_fields=["last_login_time_fail"])
        except StaffUser.DoesNotExist:
            pass

        return Response({"detail": "Invalid credentials"}, status=status.HTTP_401_UNAUTHORIZED)



class ProjectCreateAPIView(generics.CreateAPIView):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CREATE_PROJECT'),
    ]
    
    @transaction.atomic
    def perform_create(self, serializer):
        try:    
            project = serializer.save(create_user=self.request.user)
            print('project:',project)

            created_phase = PhaseType.objects.get(key='CREATED')
            sent_phase = PhaseType.objects.get(key='SENT_TO_FINANCIER')

            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=created_phase,
                comment="–ü—Ä–æ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω.",
                performed_by=self.request.user,
            )
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=sent_phase,
                comment="–ü—Ä–æ–µ–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ñ–∏–Ω–∞–Ω—Å–∏—Å—Ç—É.",
                performed_by=self.request.user,
                notify_to=project.financier
            )
        except Exception as e:
            print(e)
        
        
        

#for financier confirm project
class ProjectListNotificationFinancierView(generics.ListAPIView):
    serializer_class = ProjectSerializer
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_PROJECT_FINANCIER'),
    ]

    def get_queryset(self):
        user = self.request.user
        return Project.objects.filter(
            financier=user,
            financier_confirm=False
        )



#for notifications for prject
class ProjectListFinancierConfirmView(generics.ListAPIView):
    serializer_class = ProjectSerializer
    pagination_class = ProjectsFiancierConfirmPagination  # üëà shu yerda biriktiramiz
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_PROJECT_FINANCIER'),
    ]

    def get_queryset(self):
        user = self.request.user
        financier_confirmed = self.request.query_params.get('financier_confirmed')
        print('financier_confirmed:',financier_confirmed)
        qs=Project.objects.filter(financier=user)
        if financier_confirmed == 'true':
            qs = qs.filter(financier_confirm=True).order_by('-financier_confirm_date')
        else:
            qs = qs.filter(financier_confirm=False).order_by('-create_date')
        return qs
    
    
    
    

class UsersWithCapabilityAPIView(generics.ListAPIView):
    serializer_class = StaffUserSimpleSerializer
    permission_classes = [IsAuthenticated]
    queryset = StaffUser.objects.all()  # required by DRF if you use filter_backends

    def get_queryset(self):
        cap = self.request.query_params.get('capability')
        if not cap:
            return StaffUser.objects.none()

        return StaffUser.objects.filter(
            role__capabilities__capability_name=cap
        ).distinct()
        


class ProjectListAPIView(generics.ListAPIView):
    serializer_class = ProjectSerializer
    pagination_class = ProjectsPagination
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        capabilities = set(user.get_capability_names())

        # ‚úÖ If user is Tech Director or Fin Director ‚Äî see all projects
        if 'IS_TECH_DIR' in capabilities or 'IS_FIN_DIR' in capabilities:
            qs = Project.objects.all()
        else:
            base_q = Q(create_user=user) | Q(project_gip=user)

            if 'IS_FINANCIER' in capabilities:
                base_q |= Q(financier=user)
            if 'IS_NACH_OTDEL' in capabilities:
                base_q |= Q(finance_parts__gip_parts__tch_part_nach=user)
            if 'IS_STAFF' in capabilities:
                base_q |= Q(finance_parts__gip_parts__work_orders__wo_staff=user)

            qs = Project.objects.filter(base_q).distinct()

        # üîç Filtrlarni olish
        start_date_from = self.request.query_params.get('start_date_from')
        start_date_to = self.request.query_params.get('start_date_to')
        end_date_from = self.request.query_params.get('end_date_from')
        end_date_to = self.request.query_params.get('end_date_to')
        financier_confirmed = self.request.query_params.get('financier_confirmed')
        gip_confirmed = self.request.query_params.get('gip_confirmed')
        search = self.request.query_params.get('search')
        total_price_from = self.request.query_params.get('total_price_from')
        total_price_to = self.request.query_params.get('total_price_to')

        # üìÖ Sana bo‚Äòyicha filter
        if start_date_from:
            qs = qs.filter(start_date__gte=parse_date(start_date_from))
        if start_date_to:
            qs = qs.filter(start_date__lte=parse_date(start_date_to))
        if end_date_from:
            qs = qs.filter(end_date__gte=parse_date(end_date_from))
        if end_date_to:
            qs = qs.filter(end_date__lte=parse_date(end_date_to))

        # üí∞ Narx bo‚Äòyicha filter
        if total_price_from and total_price_from.isdigit():
            qs = qs.filter(total_price__gte=int(total_price_from))
        if total_price_to and total_price_to.isdigit():
            qs = qs.filter(total_price__lte=int(total_price_to))

        # üîé Qidiruv
        if search:
            qs = qs.filter(project_name__icontains=search)

        # ‚òëÔ∏è Holat filtrlari
        if financier_confirmed == 'true':
            qs = qs.filter(financier_confirm=True)
        elif financier_confirmed == 'false':
            qs = qs.filter(financier_confirm=False)

        if gip_confirmed == 'true':
            qs = qs.filter(gip_confirm=True)
        elif gip_confirmed == 'false':
            qs = qs.filter(gip_confirm=False)

        return qs.order_by('-create_date')


class ProjectListCreateView(ListCreateAPIView):
    serializer_class = ProjectSerializer
    pagination_class = ProjectListCreatePagination
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CREATE_PROJECT')  # Optional: adjust based on your needs
    ]

    def get_queryset(self):
        queryset = Project.objects.all().order_by('-create_date')
        search = self.request.query_params.get('search')
        if search:
            queryset = queryset.filter(Q(project_name__icontains=search))
        return queryset


    @transaction.atomic
    def perform_create(self, serializer):
        try:
            start_date = serializer.validated_data.get('start_date')
            end_date = serializer.validated_data.get('end_date')
            currency = serializer.validated_data.get('currency')
            if not currency:
                return Response({
                    "key": "create_proj.currency_required",
                    "detail": "–í–∞–ª—é—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞."
                })

            if start_date >= end_date:
                return Response({
                    "key": "create_proj.end_date_before_start_date",
                    "detail": "–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–∑–∂–µ –¥–∞—Ç—ã –Ω–∞—á–∞–ª–∞."
                })

            if date.today() > end_date:
                return Response({
                    "key": "create_proj.end_date_before_today",
                    "detail": "–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–µ–≥–æ–¥–Ω—è –∏–ª–∏ –≤ –±—É–¥—É—â–µ–º."
                })

            project = serializer.save(create_user=self.request.user)

            created_phase = PhaseType.objects.get(key='CREATED')
            sent_phase = PhaseType.objects.get(key='SENT_TO_FINANCIER')

            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=created_phase,
                comment="–ü—Ä–æ–µ–∫—Ç —Å–æ–∑–¥–∞–Ω.",
                performed_by=self.request.user,
            )

            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=sent_phase,
                comment="–ü—Ä–æ–µ–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —Ñ–∏–Ω–∞–Ω—Å–∏—Å—Ç—É.",
                performed_by=self.request.user,
                notify_to=project.financier
            )

        except Exception as e:
            return Response({
                "key": "create_proj.unknown_error",
                "detail": str(e)
            })



class ProjectRetrieveUpdateView(RetrieveUpdateAPIView):
    queryset = Project.objects.all()
    serializer_class = ProjectSerializer
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CREATE_PROJECT')  # Optional: adjust based on your needs
    ]
    lookup_field = 'project_code'

    @transaction.atomic
    def perform_update(self, serializer):
        project = serializer.instance
        start_date = serializer.validated_data.get('start_date')
        end_date = serializer.validated_data.get('end_date')

        if start_date >= end_date:
            raise ValidationError({'end_date': '–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–∑–∂–µ –¥–∞—Ç—ã –Ω–∞—á–∞–ª–∞'})#End date must be after start date.
        if date.today() > end_date:
            raise ValidationError({'end_date': '–î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–µ–≥–æ–¥–Ω—è –∏–ª–∏ –≤ –±—É–¥—É—â–µ–º.'})#End date must be today or in the future.

        serializer.save()
        
        try:
            update_phase = PhaseType.objects.get(key='PROJECT_UPDATED')
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=update_phase,
                performed_by=self.request.user,
                notify_to=project.financier,  # ‚úÖ Notify financier
                comment='–ü—Ä–æ–µ–∫—Ç –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω'
            )
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {e}")



class ConfirmProjectByFinancierView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_PROJECT_FINANCIER'),
    ]

    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        if not project_code:
            return Response({"error": "–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response({"error": "–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=status.HTTP_404_NOT_FOUND)

        # Update project fields
        project.financier_confirm = True
        project.financier_confirm_date = timezone.now()
        project.save()

        # ‚úÖ Log ActionLog and notify project creator
        try:
            phase_type = PhaseType.objects.get(key='FINANCIER_CONFIRMED')
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_type,
                performed_by=request.user,
                notify_to=project.create_user,
                comment="–ü—Ä–æ–µ–∫—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω —Ñ–∏–Ω–∞–Ω—Å–∏—Å—Ç–æ–º"  # Project confirmed by financier
            )
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {e}")  # Error creating ActionLog

        return Response({
            "message": "–ü—Ä–æ–µ–∫—Ç —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω"  # Project confirmed successfully
        }, status=status.HTTP_200_OK)
    
    
    
    
class CreateFinancialPartsView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_DIVIDE_FS_PARTS')
    ]


    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        parts_data = request.data.get('parts', [])
        user = request.user

        if not project_code or not parts_data:
            return Response({"key": "create_fpart.missing_data", "detail": "–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏ —Å–ø–∏—Å–æ–∫ —á–∞—Å—Ç–µ–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã"}, status=400)

        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response({"key": "create_fpart.project_not_found", "detail": "–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=404)

        serialized_parts = []
        errors = []

        for idx, part in enumerate(parts_data):
            part['project_code'] = project_code
            part['create_user_id'] = user.user_id
            part['fs_part_no'] = part.get('fs_part_no') or f"Part {idx + 1}"

            serializer = ProjectFinancePartCreateSerializer(data=part)
            if serializer.is_valid():
                serialized_parts.append(serializer)
            else:
                errors.append({f"{idx + 1}": serializer.errors})

        if errors:
            return Response({"key": "create_fpart.validation_error", "detail": errors}, status=400)
        
        try:
            created = [s.save() for s in serialized_parts]
            
        except IntegrityError:
            return Response({
                "key": "create_fpart.duplicate_fs_part_name_or_fs_part_no_for_the_same_project",
                "detail": "Duplicate fs_part_name or fs_part_no for the same project."
            }, status=400)
        
        try:
            phase_type = PhaseType.objects.get(key='FIN_PARTS_CREATED')
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_type,
                performed_by=user,
                notify_to=None,  # No notification
                comment="–§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —á–∞—Å—Ç–∏ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω—ã"  # Financial parts created
            )
        except PhaseType.DoesNotExist:
            return Response({"detail": "–¢–∏–ø —ç—Ç–∞–ø–∞ 'FIN_PARTS_CREATED' –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=500)
        except Exception as e:
            # print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {e}")  # Error creating ActionLog
            return Response({"detail":e}, status=500)

        return Response({'created': [ProjectFinancePartCreateSerializer(p).data for p in created]}, status=201)
        
        
        
        
    
class ProjectFinancePartsListAPIView(generics.ListAPIView):
    serializer_class = ProjectFinancePartSerializer

    def get_queryset(self):
        project_code = self.kwargs.get('project_code')
        queryset = ProjectFinancePart.objects.filter(project_code=project_code).order_by('fs_part_code')

        send_to_tech_dir = self.request.query_params.get('send_to_tech_dir')
        if send_to_tech_dir == 'true':
            queryset = queryset.filter(send_to_tech_dir=True)

        return queryset



class ProjectFinancePartsUpdateAPIView(APIView):
    permission_classes = [IsAuthenticated]
    
    @transaction.atomic
    def put(self, request, project_code):
        parts_data = request.data  # expect list
        updated_parts = []
        print('parts_data:',parts_data)


        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response({'error': '–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}, status=status.HTTP_404_NOT_FOUND)  # Project not found

        # Collect existing part codes to delete removed ones later (optional)
        existing_parts = ProjectFinancePart.objects.filter(project_code=project_code)
        existing_ids = set(existing_parts.values_list('fs_part_code', flat=True))
        incoming_ids = set(p['fs_part_code'] for p in parts_data if p.get('fs_part_code'))

        # Optional: delete removed parts
        to_delete = existing_ids - incoming_ids
        ProjectFinancePart.objects.filter(fs_part_code__in=to_delete).delete()

        for part_data in parts_data:
            part_data['project_code'] = project_code  # ensure FK is passed

            if part_data.get('fs_part_code'):
                try:
                    part = ProjectFinancePart.objects.get(fs_part_code=part_data['fs_part_code'], project_code=project_code)
                    serializer = ProjectFinancePartSerializer(part, data=part_data, context={'request': request})
                except ProjectFinancePart.DoesNotExist:
                    continue
            else:
                # Create new part
                serializer = ProjectFinancePartSerializer(data=part_data, context={'request': request})

            if serializer.is_valid():
                updated_parts.append(serializer.save())
            else:
                return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

                # –£–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–∞–≤–æ–º CAN_CHECK_AND_GIP_ATTACH (notify users with CAN_CHECK_AND_GIP_ATTACH)
        try:
            phase_type = PhaseType.objects.get(key='FIN_PARTS_UPDATED')
            notify_users = StaffUser.objects.filter(
                role__capabilities__capability_name='CAN_CHECK_AND_GIP_ATTACH'
            ).distinct()

            for user in notify_users:
                ActionLog.objects.create(
                    full_id=project.full_id,
                    path_type=project.path_type,
                    phase_type=phase_type,
                    performed_by=request.user,
                    notify_to=user,
                    comment='–§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —á–∞—Å—Ç–∏ –æ–±–Ω–æ–≤–ª–µ–Ω—ã'  # Financial parts updated
                )
        except PhaseType.DoesNotExist:
            return Response({'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'FIN_PARTS_UPDATED' –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)  # PhaseType not found
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {e}")  # Error creating ActionLog
        
        return Response(ProjectFinancePartSerializer(updated_parts, many=True).data, status=200)
    
    
    

class SendToTechDirAPIView(APIView):
    permission_classes = [IsAuthenticated]
    
    @transaction.atomic
    def put(self, request, project_code):
        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response({'error': '–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}, status=status.HTTP_404_NOT_FOUND)
        # Only parts that are not already sent
        parts = ProjectFinancePart.objects.filter(
            project_code=project_code,
            send_to_tech_dir=False
        )
        count = parts.count()
        if count == 0:
            return Response({'message': "–ù–æ–≤—ã—Ö —á–∞—Å—Ç–µ–π –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –Ω–µ—Ç"}, status=status.HTTP_200_OK)
        parts.update(send_to_tech_dir=True, send_to_tech_dir_date=now())
        
        try:
            phase_type = PhaseType.objects.get(key='SENT_TO_TECH_DIR')
        except PhaseType.DoesNotExist:
            return Response({'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'SENT_TO_TECH_DIR' –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)  # PhaseType not found
        
        
        # –£–≤–µ–¥–æ–º–∏—Ç—å –≤—Å–µ—Ö, —É –∫–æ–≥–æ –µ—Å—Ç—å –ø—Ä–∞–≤–æ CAN_CHECK_AND_GIP_ATTACH (Notify all with CAN_CHECK_AND_GIP_ATTACH)
        notify_users = StaffUser.objects.filter(
            role__capabilities__capability_name='CAN_CHECK_AND_GIP_ATTACH'
        ).distinct()
        
        for user in notify_users:
            try:
                ActionLog.objects.create(
                    full_id=project.full_id,
                    path_type=project.path_type,
                    phase_type=phase_type,
                    performed_by=request.user,
                    notify_to=user,
                    comment="–§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ —á–∞—Å—Ç–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º—É –¥–∏—Ä–µ–∫—Ç–æ—Ä—É"  # Financial parts sent to Tech Director
                )
            except Exception as e:
                print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog –¥–ª—è {user.fio}: {e}")  # Error creating ActionLog

        return Response({'message': f"{count} —á–∞—Å—Ç–µ–π –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–º—É –¥–∏—Ä–µ–∫—Ç–æ—Ä—É"}, status=status.HTTP_200_OK)  # parts sent to Tech Director
    
    
class ProjectListTechDirConfirmView(generics.ListAPIView):
    serializer_class = ProjectSerializer
    pagination_class = ProjectsFiancierConfirmPagination
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CHECK_AND_GIP_ATTACH'),
    ]

    def get_queryset(self):
        tech_dir_confirmed = self.request.query_params.get('tech_dir_confirmed')

        # Base queryset: only projects with parts sent to technical director
        qs = Project.objects.filter(finance_parts__send_to_tech_dir=True).distinct()

        if tech_dir_confirmed == 'true':
            # All parts confirmed
            qs = qs.annotate(
                unconfirmed_parts=Count('finance_parts', filter=Q(finance_parts__tech_dir_confirm=False))
            ).filter(unconfirmed_parts=0)

        elif tech_dir_confirmed == 'false':
            # Some parts not confirmed ‚Üí includes refused too
            qs = qs.annotate(
                total_parts=Count('finance_parts'),
                confirmed_parts=Count('finance_parts', filter=Q(finance_parts__tech_dir_confirm=True)),
            ).filter(
                confirmed_parts__lt=F('total_parts')
            )

        return qs.order_by('-create_date')
    
    

class TechDirVerifyAPIView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CHECK_AND_GIP_ATTACH')
    ]
    
    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        gip_user_id = request.data.get('gip_user_id')

        if not project_code or not gip_user_id:
            return Response(
                {'error': '–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –ì–ò–ü –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'},  # Project code and GIP are required
                status=400
            )


        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response(
                {'error': '–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'},  # Project not found
                status=404
            )
        # ‚úÖ Attach GIP
        project.project_gip_id = gip_user_id
        project.save()

        # ‚úÖ Confirm all finance parts
        parts = ProjectFinancePart.objects.filter(project_code=project, send_to_tech_dir=True)
        parts.update(
            tech_dir_confirm=True,
            tech_dir_confirm_date=timezone.now()
        )

        # ‚úÖ –õ–æ–≥ ‚Ññ1: TECH_DIR_CONFIRMED_AND_ATTACHED_GIP (Tech dir confirmed and attached GIP)
        try:
            phase_1 = PhaseType.objects.get(key='TECH_DIR_CONFIRMED_AND_ATTACHED_GIP')
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_1,
                performed_by=request.user,
                notify_to=project.project_gip,
                comment="–¢–µ—Ö. –¥–∏—Ä–µ–∫—Ç–æ—Ä –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –∏ –ø—Ä–∏–∫—Ä–µ–ø–∏–ª –ì–ò–ü–∞"  # Tech director confirmed and attached GIP
            )
        except PhaseType.DoesNotExist:
            return Response(
                {'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'TECH_DIR_CONFIRMED_AND_ATTACHED_GIP' –Ω–µ –Ω–∞–π–¥–µ–Ω"},  # Phase type not found
                status=500
            )
        except Exception as e:
            return Response(
                {'error': f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog (1): {str(e)}"},  # Error creating ActionLog (1)
                status=500
            )

        # ‚úÖ –õ–æ–≥ ‚Ññ2: SENT_TO_GIP (Project sent to GIP)
        try:
            phase_2 = PhaseType.objects.get(key='SENT_TO_GIP')
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_2,
                performed_by=request.user,
                notify_to=project.project_gip,
                comment="–ü—Ä–æ–µ–∫—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ì–ò–ü—É"  # Project sent to GIP
            )
        except PhaseType.DoesNotExist:
            return Response(
                {'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'SENT_TO_GIP' –Ω–µ –Ω–∞–π–¥–µ–Ω"},  # Phase type not found
                status=500
            )
        except Exception as e:
            return Response(
                {'error': f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog (2): {str(e)}"},  # Error creating ActionLog (2)
                status=500
            )

        return Response(
            {'message': '–ü—Ä–æ–µ–∫—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ì–ò–ü—É'},  # Project confirmed and sent to GIP
            status=200
        )
    
    
class TechDirRefuseAPIView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CHECK_AND_GIP_ATTACH')]

    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        comment = request.data.get('comment')

        if not project_code or not comment:
            return Response(
                {'error': '–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'},  # Project code and comment are required
                status=400
            )

        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response(
                {'error': '–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'},  # Project not found
                status=404
            )
        
        # ‚úÖ Attach GIP
        project.project_gip_id = None
        project.save()

        # ‚úÖ Confirm all finance parts
        parts = ProjectFinancePart.objects.filter(project_code=project, send_to_tech_dir=True)
        parts.update(
            tech_dir_confirm=False,
            tech_dir_confirm_date=None
        )
        
        try:
            phase_type = PhaseType.objects.get(key='TECH_DIR_REFUSED')
        except PhaseType.DoesNotExist:
            return Response(
                {'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'TECH_DIR_REFUSED' –Ω–µ –Ω–∞–π–¥–µ–Ω"},  # Phase type not found
                status=500
            )

        try:
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_type,
                comment=comment,
                performed_by=request.user,
                notify_to=project.financier  # üîî Notify financier
            )
        except Exception as e:
            return Response(
                {'error': f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {str(e)}"},  # Error creating ActionLog
                status=500
            )

        return Response(
            {'message': '–û—Ç–∫–∞–∑ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'},  # Refusal recorded
            status=200
        )



    
class PartnerListCreateView(ListCreateAPIView):
    queryset = Partner.objects.all().order_by('-update_time')
    serializer_class = PartnerSerializer
    pagination_class = PartnersPagination
    permission_classes = [IsAuthenticated,
                          HasCapabilityPermission('CAN_ADD_PARTNERS'),  # Optional if needed
                          ]

    def perform_create(self, serializer):
        serializer.save(create_user=self.request.user)


class PartnerUpdateView(RetrieveUpdateAPIView):
    queryset = Partner.objects.all()
    serializer_class = PartnerSerializer
    permission_classes = [
                        IsAuthenticated,
                        HasCapabilityPermission('CAN_ADD_PARTNERS'),  # Optional if needed
                          ]
    lookup_field = 'partner_code'
    



class TranslationListView(ListAPIView):
    queryset = Translation.objects.all()
    serializer_class = TranslationSerializer
    permission_classes = [AllowAny]
    
    
class DepartmentListCreateView(ListCreateAPIView):
    queryset = Department.objects.all().order_by('-update_time')
    serializer_class = DepartmentSerializer
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_ADD_DEPARTMENTS')]
    pagination_class = DepartmentPagination
    filter_backends = [SearchFilter]  # ‚úÖ Add this
    search_fields = ['department_name']  # ‚úÖ Searchable field

    def perform_create(self, serializer):
        serializer.save(create_user=self.request.user)
        
        
class DepartmentUpdateView(RetrieveUpdateAPIView):
    queryset = Department.objects.all()
    serializer_class = DepartmentSerializer
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_ADD_DEPARTMENTS'),  # adjust as needed
    ]
    lookup_field = 'department_id'
    





class RefuseProjectByFinancierView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_PROJECT_FINANCIER'),
    ]

    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        comment = request.data.get('comment')

        if not project_code or not comment:
            return Response({"error": "–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã"},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response({"error": "–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=status.HTTP_404_NOT_FOUND)

        try:
            phase_type = PhaseType.objects.get(key='FINANCIER_REFUSED')
        except PhaseType.DoesNotExist:
            return Response({"error": "–¢–∏–ø —ç—Ç–∞–ø–∞ 'FINANCIER_REFUSED' –Ω–µ –Ω–∞–π–¥–µ–Ω"},
                            status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        try:
            ActionLog.objects.create(
                full_id=project.full_id,
                path_type=project.path_type,
                phase_type=phase_type,
                performed_by=request.user,
                notify_to=project.create_user,
                comment=comment
            )
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog: {e}")  # Error creating ActionLog

        return Response({"message": "–û—Ç–∫–∞–∑ –ø–æ –ø—Ä–æ–µ–∫—Ç—É —É—Å–ø–µ—à–Ω–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω"}, status=status.HTTP_200_OK)  # Project refusal logged successfully
        
        
class TranslationListCreateAPIView(ListCreateAPIView):
    queryset = Translation.objects.all().order_by('-update_time')
    serializer_class = TranslationSerializer
    pagination_class = TranslationsPagination  # reuse or define similar pagination
    filter_backends = [SearchFilter]
    search_fields = ['key', 'en', 'ru', 'uz']  # üîç enables ?search=...
    # permission_classes = [IsAuthenticated,HasCapabilityPermission('CAN_MANAGE_TRANSLATIONS')]
    

    def perform_create(self, serializer):
        serializer.save(translated_by=self.request.user)


class TranslationUpdateAPIView(UpdateAPIView):
    queryset = Translation.objects.all()
    serializer_class = TranslationSerializer
    pagination_class = TranslationsPagination  # reuse or define similar pagination
    # permission_classes = [IsAuthenticated,HasCapabilityPermission('CAN_MANAGE_TRANSLATIONS')]
    lookup_field = 'translation_id'

    def perform_update(self, serializer):
        serializer.save(translated_by=self.request.user)
        
        
        
        
        
#gip confirm views
class GIPProjectListView(generics.ListAPIView):
    serializer_class = ProjectSerializer
    pagination_class = GipConfirmPagination
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_TECH_PARTS')]

    def get_queryset(self):
        user = self.request.user  # üëà Use the logged-in user directly
        gip_confirm = self.request.query_params.get('gip_confirm')
        search = self.request.query_params.get('search', '').strip()

        qs = Project.objects.filter(project_gip=user)

        if gip_confirm == 'true':
            qs = qs.filter(gip_confirm=True)
        elif gip_confirm == 'false':
            qs = qs.filter(gip_confirm=False)

        if search:
            qs = qs.filter(Q(project_name__icontains=search))

        return qs.order_by('-create_date')




class GIPConfirmAPIView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_TECH_PARTS')]

    @transaction.atomic
    def post(self, request):
        project_code = request.data.get('project_code')
        if not project_code:
            return Response(
                {'error': '–ö–æ–¥ –ø—Ä–æ–µ–∫—Ç–∞ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'},  # Project code is required
                status=400
            )

        try:
            project = Project.objects.get(project_code=project_code)
        except Project.DoesNotExist:
            return Response(
                {'error': '–ü—Ä–æ–µ–∫—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'},  # Project not found
                status=404
            )

        # ‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –ì–ò–ü–æ–º (Confirm by GIP)
        project.gip_confirm = True
        project.gip_confirm_date = timezone.now()
        project.save(update_fields=['gip_confirm', 'gip_confirm_date'])

        try:
            phase_type = PhaseType.objects.get(key='GIP_CONFIRMED')
        except PhaseType.DoesNotExist:
            return Response(
                {'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'GIP_CONFIRMED' –Ω–µ –Ω–∞–π–¥–µ–Ω"},  # Phase type not found
                status=500
            )

        # üîî –£–≤–µ–¥–æ–º–∏—Ç—å –≤—Å–µ—Ö —Å –ø—Ä–∞–≤–æ–º 'CAN_CHECK_AND_GIP_ATTACH' (Notify users with capability)
        notify_users = StaffUser.objects.filter(
                role__capabilities__capability_name='CAN_CHECK_AND_GIP_ATTACH'
            ).distinct()
        for user in notify_users:
            try:
                ActionLog.objects.create(
                    full_id=project.full_id,
                    path_type=project.path_type,
                    phase_type=phase_type,
                    performed_by=request.user,
                    notify_to=user,
                    comment="–ì–ò–ü –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –ø—Ä–æ–µ–∫—Ç"  # GIP confirmed the project
                )
            except Exception as e:
                return Response(
                    {'error': f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ ActionLog –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user.fio}: {str(e)}"},  # Error creating ActionLog for user
                    status=500
                )

        return Response(
            {'message': '–ü—Ä–æ–µ–∫—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω –ì–ò–ü–æ–º –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã'},  # Project confirmed by GIP and notifications sent
            status=200
        )

    
    
class GipFinancePartsListAPIView(generics.ListAPIView):
    serializer_class = ProjectFinancePartSerializer
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_TECH_PARTS')]

    def get_queryset(self):
        project_code = self.kwargs.get('project_code')
        queryset = ProjectFinancePart.objects.filter(project_code=project_code).order_by('fs_part_code')

        send_to_tech_dir = self.request.query_params.get('send_to_tech_dir')
        tech_dir_confirm = self.request.query_params.get('tech_dir_confirm')

        if send_to_tech_dir == 'true':
            queryset = queryset.filter(send_to_tech_dir=True)

        if tech_dir_confirm == 'true':
            queryset = queryset.filter(tech_dir_confirm=True)

        return queryset
    
    
class GipCreateTechnicalPartsView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_TECH_PARTS')]

    @transaction.atomic
    def post(self, request):
        fs_part_code = request.data.get('fs_part_code')
        parts_data = request.data.get('parts', [])

        if not fs_part_code or not parts_data:
            return Response(
                {'error': '–ö–æ–¥ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π —á–∞—Å—Ç–∏ –∏ —Å–ø–∏—Å–æ–∫ —á–∞—Å—Ç–µ–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'},  # fs_part_code and parts are required
                status=400
            )

        try:
            finance_part = ProjectFinancePart.objects.select_related('project_code').get(fs_part_code=fs_part_code)
        except ProjectFinancePart.DoesNotExist:
            return Response(
                {'error': '–§–∏–Ω–∞–Ω—Å–æ–≤–∞—è —á–∞—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'},  # Finance part not found
                status=404
            )

        try:
            phase_type = PhaseType.objects.get(key='GIP_CREATED_TECHNICAL_PARTS')
            tech_phase_type = PhaseType.objects.get(key='TECH_PART_CREATED')
        except PhaseType.DoesNotExist:
            return Response(
                {'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'GIP_CREATED_TECHNICAL_PARTS' or 'TECH_PART_CREATED' –Ω–µ –Ω–∞–π–¥–µ–Ω"},  # Phase type not found
                status=500
            )

        try:
            created_parts = []

            for part in parts_data:
                tch_user = StaffUser.objects.get(pk=part['tch_part_nach'])

                obj = ProjectGipPart.objects.create(
                    fs_part_code=finance_part,
                    tch_part_no=part['tch_part_no'],
                    tch_part_name=part['tch_part_name'],
                    tch_part_nach=tch_user,
                    tch_start_date=part['tch_start_date'],
                    tch_finish_date=part['tch_finish_date'],
                    create_user_id=request.user
                )
                created_parts.append(obj)

                # üîî Create ActionLog for each technical part to notify tch_part_nach
                ActionLog.objects.create(
                    full_id=obj.full_id,
                    path_type=obj.path_type,
                    phase_type=tech_phase_type,
                    comment="–ì–ò–ü —Å–æ–∑–¥–∞–ª —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é —á–∞—Å—Ç—å",  # GIP created technical part
                    performed_by=request.user,
                    notify_to=tch_user
                )

            # üßæ General ActionLog for the project (no notification)
            ActionLog.objects.create(
                full_id=finance_part.project_code.full_id,
                path_type=finance_part.project_code.path_type,
                phase_type=phase_type,
                comment="–ì–ò–ü —Å–æ–∑–¥–∞–ª –≤—Å–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏",  # GIP created all technical parts
                performed_by=request.user
            )

        except Exception as e:
            return Response(
                {'error': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —á–∞—Å—Ç–µ–π: {str(e)}'},  # Error creating technical parts
                status=400
            )

        return Response(
            {
                'message': '‚úÖ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏ —Å–æ–∑–¥–∞–Ω—ã –∏ –¥–µ–π—Å—Ç–≤–∏—è –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã',  # Technical parts created and logs recorded
                'count': len(created_parts)
            },
            status=status.HTTP_201_CREATED
        )


class GipUpdateTechnicalPartsView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_TECH_PARTS')]

    def post(self, request):
        fs_part_code = request.data.get('fs_part_code')
        parts_data = request.data.get('parts', [])

        if not fs_part_code or not parts_data:
            return Response({'error': '–ö–æ–¥ —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–π —á–∞—Å—Ç–∏ –∏ —Å–ø–∏—Å–æ–∫ —á–∞—Å—Ç–µ–π –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã'}, status=400)  # Finance part code and parts list are required

        try:
            finance_part = ProjectFinancePart.objects.get(fs_part_code=fs_part_code)
        except ProjectFinancePart.DoesNotExist:
            return Response({'error': '–§–∏–Ω–∞–Ω—Å–æ–≤–∞—è —á–∞—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}, status=404)  # Finance part not found

        fs_start = finance_part.fs_start_date
        fs_finish = finance_part.fs_finish_date

        incoming_codes = set()

        try:
            phase_type = PhaseType.objects.get(key='GIP_UPDATED_TECHNICAL_PARTS')
            tech_phase_type = PhaseType.objects.get(key='TECH_PART_UPDATED')
        except PhaseType.DoesNotExist:
            return Response({'error': "–¢–∏–ø —ç—Ç–∞–ø–∞ 'GIP_UPDATED_TECHNICAL_PARTS'/'TECH_PART_UPDATED' –Ω–µ –Ω–∞–π–¥–µ–Ω"}, status=500)  # PhaseType not found

        try:
            with transaction.atomic():
                for part in parts_data:
                    start = datetime.strptime(part['tch_start_date'], "%Y-%m-%d").date()
                    end = datetime.strptime(part['tch_finish_date'], "%Y-%m-%d").date()

                    if start < fs_start or end > fs_finish:
                        return Response({
                            'error': f"‚ùå –î–∞—Ç—ã –¥–ª—è —á–∞—Å—Ç–∏ #{part.get('tch_part_no')} –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –º–µ–∂–¥—É {fs_start} –∏ {fs_finish}"  # Dates must be within finance part range
                        }, status=400)
                    if start > end:
                        return Response({
                            'error': f"‚ùå –ù–∞—á–∞–ª—å–Ω–∞—è –¥–∞—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–∑–∂–µ –∫–æ–Ω–µ—á–Ω–æ–π –≤ —á–∞—Å—Ç–∏ #{part.get('tch_part_no')}"  # Start must not be after end
                        }, status=400)

                    part_code = part.get('tch_part_code')
                    if part_code:
                        incoming_codes.add(part_code)
                        try:
                            obj = ProjectGipPart.objects.get(tch_part_code=part_code)
                            obj.tch_part_no = part['tch_part_no']
                            obj.tch_part_name = part['tch_part_name']
                            obj.tch_part_nach_id = part['tch_part_nach']
                            obj.tch_start_date = part['tch_start_date']
                            obj.tch_finish_date = part['tch_finish_date']
                            obj.save()
                            part_obj = obj
                        except ProjectGipPart.DoesNotExist:
                            part_obj = ProjectGipPart.objects.create(
                                fs_part_code=finance_part,
                                tch_part_no=part['tch_part_no'],
                                tch_part_name=part['tch_part_name'],
                                tch_part_nach_id=part['tch_part_nach'],
                                tch_start_date=part['tch_start_date'],
                                tch_finish_date=part['tch_finish_date'],
                                create_user_id=request.user
                            )
                    else:
                        part_obj = ProjectGipPart.objects.create(
                            fs_part_code=finance_part,
                            tch_part_no=part['tch_part_no'],
                            tch_part_name=part['tch_part_name'],
                            tch_part_nach_id=part['tch_part_nach'],
                            tch_start_date=part['tch_start_date'],
                            tch_finish_date=part['tch_finish_date'],
                            create_user_id=request.user
                        )
                        incoming_codes.add(part_obj.tch_part_code)

                    # üîî Log for each technical part update
                    ActionLog.objects.create(
                        full_id=part_obj.full_id,
                        path_type=part_obj.path_type,
                        phase_type=tech_phase_type,
                        comment="–ì–ò–ü –æ–±–Ω–æ–≤–∏–ª —Ç–µ—Ö–Ω–∏—á–µ—Å–∫—É—é —á–∞—Å—Ç—å",  # GIP updated technical part
                        performed_by=request.user,
                        notify_to=part_obj.tch_part_nach
                    )

                # üóëÔ∏è Delete removed parts
                ProjectGipPart.objects.filter(
                    fs_part_code=finance_part
                ).exclude(tch_part_code__in=incoming_codes).delete()

                # üìò Log project level update
                ActionLog.objects.create(
                    full_id=finance_part.project_code.full_id,
                    path_type=finance_part.project_code.path_type,
                    phase_type=phase_type,
                    comment="–ì–ò–ü –æ–±–Ω–æ–≤–∏–ª —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏ –ø—Ä–æ–µ–∫—Ç–∞",  # GIP updated project technical parts
                    performed_by=request.user
                )

        except Exception as e:
            return Response({'error': f'‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö —á–∞—Å—Ç–µ–π: {str(e)}'}, status=400)  # Failed to update technical parts

        return Response({'message': '‚úÖ –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —á–∞—Å—Ç–∏ —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω—ã'}, status=200)  # Technical parts updated successfully





class ProjectGipPartListView(ListAPIView):
    serializer_class = ProjectGipPartSerializer
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_WORK_ORDER')]
    pagination_class=ProjectGipPartPagination

    def get_queryset(self):
        return ProjectGipPart.objects.filter(tch_part_nach=self.request.user).order_by('-create_date')
    
    
    
    
class RefuseTechPartView(APIView):
    def get(self, request, tch_part_code):
        part = get_object_or_404(ProjectGipPart, pk=tch_part_code)
        try:
            refusal_phase = PhaseType.objects.get(key='TECH_PART_REFUSED')
            action = ActionLog.objects.filter(
                full_id=part.full_id,
                path_type=part.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ TECH_PART_REFUSED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—Ç–∫–∞–∑–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.'}, status=status.HTTP_404_NOT_FOUND)

        serializer = ActionLogSerializer(action)
        return Response(serializer.data)

    def post(self, request, tch_part_code):
        part = get_object_or_404(ProjectGipPart, pk=tch_part_code)

        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='TECH_PART_REFUSED')
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ TECH_PART_REFUSED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        try:
            ActionLog.objects.create(
                full_id=part.full_id,
                path_type=part.path_type,
                phase_type=refusal_phase,
                comment=comment,
                performed_by=request.user,
                notify_to=part.create_user_id,
            )
        except Exception as e:
            return Response({'detail': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∂—É—Ä–Ω–∞–ª–∞ –¥–µ–π—Å—Ç–≤–∏–π: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({'detail': '–û—Ç–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω.'}, status=status.HTTP_201_CREATED)

    def put(self, request, tch_part_code):
        part = get_object_or_404(ProjectGipPart, pk=tch_part_code)

        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='TECH_PART_REFUSED')
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ TECH_PART_REFUSED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        try:
            action = ActionLog.objects.filter(
                full_id=part.full_id,
                path_type=part.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
            action.comment = comment
            action.save()
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ó–∞–ø–∏—Å—å –æ—Ç–∫–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.'}, status=status.HTTP_404_NOT_FOUND)

        return Response({'detail': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –æ—Ç–∫–∞–∑—É —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω.'}, status=status.HTTP_200_OK)  
    
    
    
class ConfirmTechPartView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_WORK_ORDER')]

    def post(self, request, tch_part_code):
        part = get_object_or_404(ProjectGipPart, pk=tch_part_code)

        if part.nach_otd_confirm:
            return Response({'detail': '–ß–∞—Å—Ç—å —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞.'}, status=status.HTTP_400_BAD_REQUEST)  # Part already confirmed

        try:
            confirm_phase = PhaseType.objects.get(key='TECH_PART_CONFIRMED')
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ TECH_PART_CONFIRMED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)  # PhaseType not found

        try:
            with transaction.atomic():
                part.nach_otd_confirm = True
                part.nach_otd_confirm_date = timezone.now()
                part.save()

                # üîî Log for the technical part (notifies creator)
                ActionLog.objects.create(
                    full_id=part.full_id,
                    path_type=part.path_type,
                    phase_type=confirm_phase,
                    performed_by=request.user,
                    notify_to=part.create_user_id,
                    comment='–ß–∞—Å—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞'  # Part confirmed
                )

        except Exception as e:
            return Response({'detail': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)  # Error during confirmation

        return Response({'detail': '–ß–∞—Å—Ç—å —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞.'}, status=status.HTTP_200_OK)  # Part confirmed successfully

    
    
    
class CreateWorkOrderView(APIView):
    permission_classes = [IsAuthenticated,HasCapabilityPermission('CAN_CREATE_WORK_ORDER')]

    @transaction.atomic
    def post(self, request):
        tch_part_code = request.data.get('tch_part_code')
        orders = request.data.get('orders', [])

        if not tch_part_code or not orders:
            return Response({'detail': '–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —á–∞—Å—Ç—å –∏–ª–∏ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞–Ω–∏–π'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            tech_part = ProjectGipPart.objects.select_related('fs_part_code__project_code').get(pk=tch_part_code)
        except ProjectGipPart.DoesNotExist:
            return Response({'detail': '–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —á–∞—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'}, status=status.HTTP_404_NOT_FOUND)

        try:
            phase_type = PhaseType.objects.get(key='WORK_ORDER_CREATED')
        except PhaseType.DoesNotExist:
            phase_type = None

        for order_data in orders:
            serializer = WorkOrderCreateSerializer(data=order_data)
            serializer.is_valid(raise_exception=True)

            work_order = serializer.save(
                tch_part_code=tech_part,
                create_user=request.user
            )

            # ‚ûï Create ActionLog
            ActionLog.objects.create(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=phase_type,
                performed_by=request.user,
                notify_to=work_order.wo_staff,  # üëà Notify the assigned staff
                comment=f"–ù–∞—Ä—è–¥ ‚Ññ{work_order.wo_no} —Å–æ–∑–¥–∞–Ω"
            )
         # üßæ Project-level ActionLog (no notify)
        ActionLog.objects.create(
            full_id=tech_part.fs_part_code.project_code.full_id,
            path_type=tech_part.fs_part_code.project_code.path_type,
            phase_type=phase_type,
            performed_by=request.user,
            comment='–°–æ–∑–¥–∞–Ω—ã –Ω–∞—Ä—è–¥—ã –ø–æ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —á–∞—Å—Ç–∏'  # Work orders created for technical part
        )


        return Response({'detail': '‚úÖ –ù–∞—Ä—è–¥—ã —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω—ã'}, status=status.HTTP_201_CREATED)
    
    

class LoadWorkOrdersByPartView(APIView):
    permission_classes = [IsAuthenticated,HasCapabilityPermission('CAN_CREATE_WORK_ORDER')]

    def get(self, request, tch_part_code):
        orders = WorkOrder.objects.filter(tch_part_code=tch_part_code).order_by('wo_no')
        serializer = WorkOrderSerializer(orders, many=True)
        return Response(serializer.data)


    
    
    
class UpdateWorkOrdersView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CREATE_WORK_ORDER')]

    def put(self, request):
        data = request.data
        tch_part_code = data.get('tch_part_code')
        orders = data.get('orders', [])

        if not tch_part_code or not isinstance(orders, list):
            return Response({'detail': 'Invalid input.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            part = ProjectGipPart.objects.get(tch_part_code=tch_part_code)
        except ProjectGipPart.DoesNotExist:
            return Response({'detail': 'Part not found.'}, status=status.HTTP_404_NOT_FOUND)

        try:
            phase_type = PhaseType.objects.get(key='WORK_ORDER_UPDATED')
        except PhaseType.DoesNotExist:
            phase_type = None

        with transaction.atomic():
            # Get all existing orders for the part
            existing_wos = WorkOrder.objects.filter(tch_part_code=part)
            existing_map = {wo.pk: wo for wo in existing_wos}
            incoming_ids = {o.get('wo_id') for o in orders if o.get('wo_id')}
            print('incoming_ids',incoming_ids)

            # Process updates and creates
            for o in orders:
                wo_id = o.get('wo_id')

                if wo_id and wo_id in existing_map:
                    # Update existing
                    wo = existing_map[wo_id]
                    wo.wo_no = o['wo_no']
                    wo.wo_name = o['wo_name']
                    wo.wo_start_date = o['wo_start_date']
                    wo.wo_finish_date = o['wo_finish_date']
                    wo.wo_staff_id = o['wo_staff']
                    wo.save()
                else:
                    # Create new
                    wo = WorkOrder.objects.create(
                        tch_part_code=part,
                        wo_no=o['wo_no'],
                        wo_name=o['wo_name'],
                        wo_start_date=o['wo_start_date'],
                        wo_finish_date=o['wo_finish_date'],
                        wo_staff_id=o['wo_staff'],
                        create_user_id=request.user.user_id,
                    )

                # Action log
                ActionLog.objects.create(
                    full_id=wo.full_id,
                    path_type=wo.path_type,
                    phase_type=phase_type,
                    performed_by=request.user,
                    notify_to=wo.wo_staff,
                    comment=f"–ù–∞—Ä—è–¥ ‚Ññ{wo.wo_no} –æ–±–Ω–æ–≤–ª–µ–Ω –∏–ª–∏ —Å–æ–∑–¥–∞–Ω"
                )

            # Delete those not in incoming
            to_delete = [wo for wo_id, wo in existing_map.items() if wo_id not in incoming_ids]
            for wo in to_delete:
                wo.delete()

        return Response({'detail': 'Work orders updated successfully'}, status=status.HTTP_200_OK)






class CompleteWorkOrderListAPIView(ListAPIView):
    serializer_class = CompleteWorkOrderSerializer
    permission_classes = [IsAuthenticated,HasCapabilityPermission('CAN_COMPLETE_WORK_ORDER')]
    pagination_class = CompleteWorkOrderPagination

    def get_queryset(self):
        return WorkOrder.objects.filter(wo_staff=self.request.user).order_by('-wo_start_date')
    
    
    
class RefuseWorkOrderView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_COMPLETE_WORK_ORDER')]
    
    
    def get(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED')
            action = ActionLog.objects.filter(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
            print('action:',action)
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ WORK_ORDER_REFUSED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—Ç–∫–∞–∑–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.'}, status=status.HTTP_404_NOT_FOUND)

        serializer = ActionLogSerializer(action)
        return Response(serializer.data)

    def post(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED')
            ActionLog.objects.create(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase,
                comment=comment,
                performed_by=request.user,
                notify_to=work_order.create_user,
            )
        except Exception as e:
            return Response({'detail': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∂—É—Ä–Ω–∞–ª–∞ –¥–µ–π—Å—Ç–≤–∏–π: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({'detail': '–û—Ç–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω.'}, status=status.HTTP_201_CREATED)

    def put(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED')
            action = ActionLog.objects.filter(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
            action.comment = comment
            action.save()
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ó–∞–ø–∏—Å—å –æ—Ç–∫–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.'}, status=status.HTTP_404_NOT_FOUND)

        return Response({'detail': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –æ—Ç–∫–∞–∑—É —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω.'}, status=status.HTTP_200_OK)
    
    
    
    


class WorkOrderConfirmView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_COMPLETE_WORK_ORDER')]

    def post(self, request, wo_id):
        order = get_object_or_404(WorkOrder, pk=wo_id)

        if order.staff_confirm:
            return Response({'detail': '–†–∞–±–æ—á–∏–π –Ω–∞—Ä—è–¥ —É–∂–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            confirm_phase = PhaseType.objects.get(key='WORK_ORDER_CONFIRMED')
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ WORK_ORDER_CONFIRMED –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        order.staff_confirm = True
        order.save()

        try:
            ActionLog.objects.create(
                full_id=order.full_id,
                path_type=order.path_type,
                phase_type=confirm_phase,
                performed_by=request.user,
                notify_to=order.create_user,
                comment='–†–∞–±–æ—á–∏–π –Ω–∞—Ä—è–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω'
            )
        except Exception as e:
            return Response({'detail': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –ª–æ–≥–∞: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({'detail': '–†–∞–±–æ—á–∏–π –Ω–∞—Ä—è–¥ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω.'}, status=status.HTTP_200_OK)
    
    
    
class CompleteOrUpdateWorkOrderView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_COMPLETE_WORK_ORDER')]
    parser_classes = [MultiPartParser, FormParser]

    def post(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)

        wo_answer = request.data.get('wo_answer', '').strip()
        wo_remark = request.data.get('wo_remark', '').strip()
        print('wo_answer',wo_answer)
        print('wo_remark',wo_remark)

        if not wo_answer:
            return Response({'error': 'Answer is required'}, status=status.HTTP_400_BAD_REQUEST)

        work_order.wo_answer = wo_answer
        work_order.wo_remark = wo_remark
        work_order.answer_date = timezone.now()
        work_order.staff_confirm = True
        work_order.save()

        # ‚úÖ Delete removed files
        try:
            deleted_file_ids = json.loads(request.data.get('deleted_file_ids', '[]'))
            WorkOrderFile.objects.filter(id__in=deleted_file_ids, work_order=work_order).delete()
        except (ValueError, ValidationError):
            pass  # Optional: handle JSON decode error

        # Save uploaded files
        for file in request.FILES.getlist('files'):
            WorkOrderFile.objects.create(work_order=work_order,
                                         file=file,
                                         original_name=file.name  # ‚úÖ original name from uploaded file
                                         )

        # Log action
        phase_type = PhaseType.objects.filter(key='WORK_ORDER_COMPLETED').first()
        ActionLog.objects.create(
            full_id=work_order.full_id,
            path_type=work_order.path_type,
            phase_type=phase_type,
            comment=wo_remark,
            performed_by=request.user,
            notify_to=work_order.create_user  # ‚úÖ Notify the work order's creator
        )

        return Response({'success': True}, status=status.HTTP_200_OK)




#notifications
class MyNotificationLogsView(ListAPIView):
    permission_classes = [IsAuthenticated]
    serializer_class = ActionLogNotificationSerializer
    pagination_class = NotificationsPagination

    def get_queryset(self):
        user = self.request.user
        identified_param = self.request.query_params.get('identified')

        queryset = ActionLog.objects.filter(notify_to=user).order_by('-performed_at')

        # Optional: apply filtering based on 'identified' query param
        if identified_param is not None:
            if identified_param.lower() == 'true':
                queryset = queryset.filter(identified=True)
            elif identified_param.lower() == 'false':
                queryset = queryset.filter(identified=False)

        # Filter out logs with missing related objects
        valid_logs = []
        for log in queryset:
            try:
                parts = log.full_id.strip('/').split('/')
                if log.path_type == "PROJECT" and Project.objects.filter(project_code=int(parts[0])).exists():
                    valid_logs.append(log)
                elif log.path_type == "FIN_PART" and ProjectFinancePart.objects.filter(fs_part_code=int(parts[1])).exists():
                    valid_logs.append(log)
                elif log.path_type == "TECH_PART" and ProjectGipPart.objects.filter(tch_part_code=int(parts[2])).exists():
                    valid_logs.append(log)
                elif log.path_type == "WORK_ORDER" and WorkOrder.objects.filter(wo_id=int(parts[3])).exists():
                    valid_logs.append(log)
            except Exception:
                continue

        return valid_logs


class MarkActionLogIdentifiedView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, action_id):
        log = get_object_or_404(ActionLog, pk=action_id)
        log.identified = True
        log.identified_time = timezone.now()
        log.save()
        return Response({'success': True})



class NotificationCountView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        queryset = ActionLog.objects.filter(notify_to=user,identified=False)
                # Filter out logs with missing related objects
        valid_logs = []
        for log in queryset:
            try:
                parts = log.full_id.strip('/').split('/')
                if log.path_type == "PROJECT" and Project.objects.filter(project_code=int(parts[0])).exists():
                    valid_logs.append(log)
                elif log.path_type == "FIN_PART" and ProjectFinancePart.objects.filter(fs_part_code=int(parts[1])).exists():
                    valid_logs.append(log)
                elif log.path_type == "TECH_PART" and ProjectGipPart.objects.filter(tch_part_code=int(parts[2])).exists():
                    valid_logs.append(log)
                elif log.path_type == "WORK_ORDER" and WorkOrder.objects.filter(wo_id=int(parts[3])).exists():
                    valid_logs.append(log)
            except Exception:
                continue
        count=len(valid_logs)
        print('count:',count)
        return Response({"count": count})


# üî¢ Define your custom phase order
PHASE_ORDER_MAP = {
    'CREATED': 1,
    'SENT_TO_FINANCIER': 2,
    'FINANCIER_CONFIRMED': 3,
    'FIN_PARTS_CREATED': 4,
    'SENT_TO_TECH_DIR': 5,
    'TECH_DIR_CONFIRMED_AND_ATTACHED_GIP': 6,
    'SENT_TO_GIP': 7,
    'GIP_CONFIRMED': 8,
    'GIP_CREATED_TECHNICAL_PARTS': 9,
    'WORK_ORDER_CREATED': 10,
}

class ProjectPhaseProgressView(APIView):
    # permission_classes = [IsAuthenticated]

    def get(self, request, project_code):
        project = get_object_or_404(Project, project_code=project_code)
        full_id_prefix = f"{project.project_code}/"

        # Fetch all project-level actions sorted by latest first
        actions = (
            ActionLog.objects
            .filter(full_id__startswith=full_id_prefix, path_type='PROJECT')
            .select_related('phase_type', 'performed_by')
            .order_by('-performed_at')  # latest first
        )

        seen_phases = set()
        result = []

        for action in actions:
            phase_key = action.phase_type.key if action.phase_type else None
            order = PHASE_ORDER_MAP.get(phase_key)

            if phase_key and order and phase_key not in seen_phases:
                result.append({
                    'action_id': action.action_id,
                    'phase_key': phase_key,
                    'order': order,
                    'performed_at': action.performed_at,
                })
                seen_phases.add(phase_key)

        # Sort result by the defined phase order
        result.sort(key=lambda x: x['order'])

        return Response(result)





class FinishedWorkOrderListView(ListAPIView):
    serializer_class = CompleteWorkOrderSerializer
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_FINISHED_WORK_ORDER')
    ]
    pagination_class=CompleteWorkOrderPagination

    def get_queryset(self):
        user = self.request.user

        return WorkOrder.objects.filter(
            create_user=user,
            staff_confirm=True,
            wo_answer__isnull=False,
            answer_date__isnull=False
        ).order_by('-answer_date')
        
        

class ConfirmFinishedWorkOrderView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_FINISHED_WORK_ORDER')
    ]

    @transaction.atomic
    def post(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, wo_id=wo_id)

        work_order.finished = True
        work_order.finished_date = timezone.now()
        work_order.save()  # Save inside atomic block

        phase_type = PhaseType.objects.filter(key='WORK_ORDER_FINISHED').first()

        # ‚úÖ Create ActionLog
        ActionLog.objects.create(
            full_id=work_order.full_id,
            path_type=work_order.path_type,
            phase_type=phase_type,
            comment='–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –∫–∞–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–µ',
            performed_by=request.user,
            notify_to=work_order.wo_staff
        )

        return Response({'detail': '–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –∫–∞–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–µ.'}, status=status.HTTP_200_OK)




class UnlockFinishedWorkOrderView(APIView):
    permission_classes = [
        IsAuthenticated,
        HasCapabilityPermission('CAN_CONFIRM_FINISHED_WORK_ORDER')
    ]

    @transaction.atomic
    def post(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, wo_id=wo_id)

        work_order.finished = False
        work_order.finished_date = timezone.now()
        work_order.save()  # Save inside atomic block

        phase_type = PhaseType.objects.filter(key='WORK_ORDER_UNLOCKED').first()

        # ‚úÖ Create ActionLog
        ActionLog.objects.create(
            full_id=work_order.full_id,
            path_type=work_order.path_type,
            phase_type=phase_type,
            comment='–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞—á–∞–ª—å–Ω–∏–∫–æ–º –æ—Ç–¥–µ–ª–∞',
            performed_by=request.user,
            notify_to=work_order.wo_staff
        )

        return Response({'detail': '–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ –Ω–∞—á–∞–ª—å–Ω–∏–∫–æ–º –æ—Ç–¥–µ–ª–∞'}, status=status.HTTP_200_OK)
    
    
    
    
    
    
class RefuseFinishedWorkOrderView(APIView):
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_CONFIRM_FINISHED_WORK_ORDER')]
    
    
    def get(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED_BY_NACH_OTDEL')
            action = ActionLog.objects.filter(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
            print('action:',action)
        except PhaseType.DoesNotExist:
            return Response({'detail': '–¢–∏–ø —ç—Ç–∞–ø–∞ WORK_ORDER_REFUSED_BY_NACH_OTDEL –Ω–µ –Ω–∞–π–¥–µ–Ω.'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—Ç–∫–∞–∑–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.'}, status=status.HTTP_404_NOT_FOUND)

        serializer = ActionLogSerializer(action)
        return Response(serializer.data)

    def post(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED_BY_NACH_OTDEL')
            ActionLog.objects.create(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase,
                comment=comment,
                performed_by=request.user,
                notify_to=work_order.create_user,
            )
        except Exception as e:
            return Response({'detail': f'–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∂—É—Ä–Ω–∞–ª–∞ –¥–µ–π—Å—Ç–≤–∏–π: {str(e)}'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        return Response({'detail': '–û—Ç–∫–∞–∑ —É—Å–ø–µ—à–Ω–æ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω.'}, status=status.HTTP_201_CREATED)

    def put(self, request, wo_id):
        work_order = get_object_or_404(WorkOrder, pk=wo_id)
        comment = request.data.get('comment', '').strip()
        if not comment:
            return Response({'detail': '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–∞–∑–∞.'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            refusal_phase = PhaseType.objects.get(key='WORK_ORDER_REFUSED_BY_NACH_OTDEL')
            action = ActionLog.objects.filter(
                full_id=work_order.full_id,
                path_type=work_order.path_type,
                phase_type=refusal_phase
            ).latest('performed_at')
            action.comment = comment
            action.save()
        except ActionLog.DoesNotExist:
            return Response({'detail': '–ó–∞–ø–∏—Å—å –æ—Ç–∫–∞–∑–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.'}, status=status.HTTP_404_NOT_FOUND)

        return Response({'detail': '–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –æ—Ç–∫–∞–∑—É —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª—ë–Ω.'}, status=status.HTTP_200_OK)
    
    
    
    



class StaffManagementUsersListView(generics.ListAPIView):
    serializer_class = StaffManagementUserSerializer
    permission_classes = [IsAuthenticated, HasCapabilityPermission('CAN_MANAGE_STAFF')]
    queryset = StaffUser.objects.all().order_by('-update_time')  # ‚úÖ Show latest updated first
    filter_backends = [filters.SearchFilter]
    search_fields = ['fio', 'username']  # ‚úÖ Allow search by name or username
    pagination_class = StaffManagementPagination
    
    
    
class StaffMgDepartmentListAPIView(ListAPIView):
    queryset = Department.objects.all().order_by('department_name')
    serializer_class = DepartmentSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [SearchFilter]
    search_fields = ['department_name']
    
    
    
    

class StaffUserUpdateAPIView(APIView):
    permission_classes = [IsAuthenticated]
    parser_classes = [MultiPartParser, FormParser]

    def patch(self, request, user_id):
        try:
            staff = StaffUser.objects.get(user_id=user_id)
        except StaffUser.DoesNotExist:
            return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)

        # ‚úÖ Handle basic text fields (excluding 'position')
        for field in ['fio', 'phone_number', 'address', 'pnfl']:
            value = request.data.get(field)
            if value is not None:
                setattr(staff, field, value)

        # ‚úÖ Handle 'position' as ForeignKey
        position_id = request.data.get('position')
        if position_id not in [None, '', 'null']:
            try:
                staff.position = JobPosition.objects.get(pk=position_id)
            except JobPosition.DoesNotExist:
                return Response({"detail": "Job position not found."}, status=400)
        else:
            staff.position = None

        # ‚úÖ Handle date fields
        for date_field in ['birthday', 'position_start_date']:
            val = request.data.get(date_field)
            if val in [None, '', 'null']:
                setattr(staff, date_field, None)
            else:
                setattr(staff, date_field, val)

        # ‚úÖ Handle department ForeignKey
        dept_id = request.data.get('department')
        if dept_id not in [None, '', 'null']:
            try:
                staff.department = Department.objects.get(pk=dept_id)
            except Department.DoesNotExist:
                return Response({"detail": "Department not found."}, status=400)
        else:
            staff.department = None

        # ‚úÖ Handle profile image upload
        image = request.FILES.get('profile_image')
        if image:
            if image.size > 10 * 1024 * 1024:
                return Response({"detail": "Image must be ‚â§ 10MB"}, status=400)
            staff.profile_image = image

        # ‚úÖ Save the updated staff
        staff.save()
        return Response({"detail": "Updated successfully."})
    
    
    
    
    
class ToggleVacationAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def patch(self, request, user_id):
        try:
            staff = StaffUser.objects.get(user_id=user_id)
        except StaffUser.DoesNotExist:
            return Response({"detail": "User not found."}, status=status.HTTP_404_NOT_FOUND)

        # Extract data
        on_vocation = request.data.get('on_vocation')
        start_date = request.data.get('on_vocation_start')
        end_date = request.data.get('on_vocation_end')

        if on_vocation:
            if not start_date or not end_date:
                return Response({"detail": "Vacation start and end dates are required."}, status=400)
            staff.on_vocation = True
            staff.on_vocation_start = start_date
            staff.on_vocation_end = end_date
        else:
            staff.on_vocation = False
            staff.on_vocation_start = None
            staff.on_vocation_end = None

        staff.save()
        return Response({"detail": "Vacation status updated successfully."}, status=200)
    
    
    
    
    
class JobPositionsByDepartmentView(ListAPIView):
    serializer_class = SimpleJobPositionSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        department_id = self.kwargs.get('department_id')
        return JobPosition.objects.filter(department_id=department_id).order_by('-create_time')


class JobPositionCreateView(CreateAPIView):
    queryset = JobPosition.objects.all()
    serializer_class = JobCreatePositionSerializer
    permission_classes = [IsAuthenticated]

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        try:
            serializer.is_valid(raise_exception=True)
            self.perform_create(serializer)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        except ValidationError:
            return Response(
                {"detail": "add_depart.duplicate_position_name"},
                status=status.HTTP_400_BAD_REQUEST
            )

    def perform_create(self, serializer):
        serializer.save(create_user=self.request.user)
        
        
        
class JobPositionDeleteView(DestroyAPIView):
    queryset = JobPosition.objects.all()
    serializer_class = SimpleJobPositionSerializer
    permission_classes = [IsAuthenticated]
    lookup_field = 'position_id'



class JobPositionUpdateView(UpdateAPIView):
    queryset = JobPosition.objects.all()
    serializer_class = JobCreatePositionSerializer
    permission_classes = [IsAuthenticated]
    lookup_field = 'position_id'

    def update(self, request, *args, **kwargs):
        instance = self.get_object()
        data = request.data.copy()

        position_name = data.get('position_name')
        department = data.get('department')

        # ‚úÖ Ignore current instance when checking duplicates
        if position_name and department:
            exists = JobPosition.objects.filter(
                position_name=position_name,
                department=department
            ).exclude(position_id=instance.position_id).exists()

            if exists:
                return Response(
                    {"detail": "add_depart.duplicate_position_name"},
                    status=status.HTTP_400_BAD_REQUEST
                )

        return super().update(request, *args, **kwargs)






class MyDepartmentsTreeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user_department = request.user.department
        if not user_department:
            return Response({'detail': 'User has no department.'}, status=404)

        data = MyDepartmentTreeSerializer(user_department).data
        return Response(data)
    
    
class StaffByDepartmentView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, department_id):
        # Get all positions in this department
        all_positions = JobPosition.objects.filter(department_id=department_id).select_related('parent').order_by('position_name')
        all_users = StaffUser.objects.filter(department_id=department_id).select_related('position').order_by('fio')

        # Build map: {position_id: [staff]}
        staff_map = {}
        for user in all_users:
            pid = user.position_id
            staff_map.setdefault(pid, []).append(user)

        # Build tree: {parent_id: [positions]}
        from collections import defaultdict
        pos_tree = defaultdict(list)
        for pos in all_positions:
            parent_id = pos.parent_id
            pos_tree[parent_id].append(pos)

        # Recursively walk the position tree and collect users
        def collect_users(position_id=None):
            result = []
            for pos in pos_tree.get(position_id, []):
                result.extend(staff_map.get(pos.position_id, []))
                result.extend(collect_users(pos.position_id))
            return result

        ordered_staff = collect_users()

        serializer = MyStaffTreeSerializer(ordered_staff, many=True)
        return Response(serializer.data)
    
    
    
class ChatMessageListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request, task_id):
        user = request.user
        task = get_object_or_404(UserTask, pk=task_id)

        # Check that user is either sender (create_user) or receiver
        if user != task.create_user and user != task.receiver:
            return Response({"detail": "You are not authorized to view messages for this task."}, status=403)

        messages = ChatMessage.objects.filter(task=task).order_by('send_time')
        data = ChatMessageSerializer(messages, many=True, context={'request': request}).data
        return Response(data)




class MarkChatMessagesReadView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, task_id):
        user = request.user
        task = get_object_or_404(UserTask, pk=task_id)
        # Mark only messages where the current user is the receiver
        updated_count = ChatMessage.objects.filter(
            task=task,
            receiver=user,
            is_read=False
        ).update(is_read=True, read_time=timezone.now())

        return Response({
            'status': 'success',
            'marked_as_read': updated_count
        })


class ChatMessageSendView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        user = request.user
        task_id = request.data.get('task_id')
        message = request.data.get('message', '').strip()

        # üîí Validate required fields
        if not task_id:
            return Response({'detail': 'Task ID is required.'}, status=status.HTTP_400_BAD_REQUEST)
        if not message:
            return Response({'detail': 'Message cannot be empty.'}, status=status.HTTP_400_BAD_REQUEST)

        # üîé Get task and validate permission
        task = get_object_or_404(UserTask, pk=task_id)
        if user != task.create_user and user != task.receiver:
            return Response({'detail': 'You are not authorized to send messages for this task.'}, status=status.HTTP_403_FORBIDDEN)

        # üë§ Determine receiver
        receiver = task.receiver if user == task.create_user else task.create_user

        # üí¨ Create message
        ChatMessage.objects.create(
            task=task,
            sender=user,
            receiver=receiver,
            message=message
        )

        return Response({'status': 'success', 'message': '‚úÖ Message sent successfully.'}, status=status.HTTP_201_CREATED)



class ChatMessageSendFileView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        user = request.user
        task_id = request.data.get('task_id')
        message = request.data.get('message', '').strip()
        files = request.FILES.getlist('files')

        # ‚úÖ Validate
        if not task_id:
            return Response({'detail': 'Task ID is required.'}, status=status.HTTP_400_BAD_REQUEST)
        if not files:
            return Response({'detail': 'At least one file is required.'}, status=status.HTTP_400_BAD_REQUEST)

        # üìå Get task and check permissions
        task = get_object_or_404(UserTask, pk=task_id)
        if user != task.create_user and user != task.receiver:
            return Response({'detail': 'You are not authorized to send files for this task.'}, status=status.HTTP_403_FORBIDDEN)

        receiver = task.receiver if user == task.create_user else task.create_user

        # üí¨ Create ChatMessage with optional message
        chat_msg = ChatMessage.objects.create(
            task=task,
            sender=user,
            receiver=receiver,
            message=message or None
        )

        # üìé Save valid files
        for f in files:
            if f.size > 300 * 1024 * 1024:
                continue  # Skip files > 300MB
            ChatMessageFile.objects.create(
                chat_message=chat_msg,
                file=f,
                file_original_name=f.name
            )

        return Response({'status': 'success', 'message': '‚úÖ Files sent successfully.'}, status=status.HTTP_201_CREATED)



class UserTaskCreateView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        title = request.data.get('title')
        receiver_id = request.data.get('receiver')

        if not title or not receiver_id:
            return Response({'detail': 'task.title_or_receiver_missed'}, status=400)

        try:
            UserTask.objects.create(
                title=title,
                receiver_id=receiver_id,
                create_user=request.user,
                create_time=timezone.now(),
                update_time=timezone.now()
            )
            return Response({'detail': 'task.created_successfully'}, status=201)

        except Exception:
            return Response({'detail': 'task.creation_failed'}, status=400)
        
        
        
class UserTaskListView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        status_filter = request.query_params.get('status')  # 'done' or 'not_done'
        search_query = request.query_params.get('search', '').strip().lower()

        queryset = UserTask.objects.filter(
            Q(receiver=request.user) | Q(create_user=request.user)
        )

        if status_filter == 'done':
            queryset = queryset.filter(done=True).order_by('-done_time')
        else:
            queryset = queryset.filter(done=False).order_by('-create_time')

        if search_query:
            queryset = queryset.filter(
                Q(title__icontains=search_query) |
                Q(task_id__icontains=search_query) |
                Q(receiver__fio__icontains=search_query) |
                Q(receiver__position__position_name__icontains=search_query) |
                Q(create_user__fio__icontains=search_query) |
                Q(create_user__position__position_name__icontains=search_query)
            )

        serializer = UserTaskSerializer(queryset, many=True, context={'request': request})
        return Response(serializer.data)
    
    
    
class MarkTaskAsDoneView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request, task_id):
        task = get_object_or_404(UserTask, pk=task_id)
        
        if task.done:
            return Response({'detail': 'Task is already marked as done.'}, status=status.HTTP_400_BAD_REQUEST)

        task.done = True
        task.done_time = timezone.now()
        task.save()

        return Response({'detail': 'Task marked as done successfully.'}, status=status.HTTP_200_OK)
    



class UnreadMessagesMinimalView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        unread_messages = ChatMessage.objects.filter(
            receiver=user,
            is_read=False
        ).select_related('sender', 'receiver', 'task').prefetch_related('files').order_by('-send_time')  # newest messages at the top

        serializer = UnreadSimpleMessageSerializer(unread_messages, many=True, context={'request': request})
        return Response(serializer.data)




class CurrencyListView(ListAPIView):
    queryset = Currency.objects.all().order_by('currency_name')
    serializer_class = CurrencySerializer
    permission_classes = [IsAuthenticated]
    # pagination_class = PartnersPagination